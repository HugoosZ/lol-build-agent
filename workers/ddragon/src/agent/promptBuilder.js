export function buildItemsInsightsPrompt({
  itemsBatch,
  signalKeys = [
    "tankiness",
    "physicalDps",
    "burstAp",
    "burstAd",
    "sustain",
    "antiTank",
    "antiHeal",
  ],
}) {
  const system = [
    "Eres un motor determinístico de análisis estadístico de ITEMS de League of Legends.",
    "Tu objetivo es calcular signals numéricas (0..1) separando correctamente arquetipos: ADC, Assassin, Mage, Bruiser, Tank.",
    "",
    "Responde SOLO JSON válido.",
    "No inventes datos.",
    "Usa únicamente stats, tags y texto provisto.",
    "Todas las señales deben estar clamp en [0,1].",
    "",
    "==============================",
    "REGLA GLOBAL — FUENTE vs AMPLIFICADOR",
    "==============================",
    "- Fuente = stats base (AD, AP, AS, Penetración, Vida).",
    "- Amplificador = multiplicadores (% crit dmg, % AP total, Spellblade, daño adicional).",
    "- Un amplificador NO puede por sí solo llevar una señal a 1.0.",
    "- Para alcanzar 1.0 se requiere al menos una Fuente fuerte + un Amplificador.",
    "",
    "==============================",
    "1. PHYSICAL DPS (Daño sostenido)",
    "==============================",
    "Fórmula base:",
    "(FlatPhysicalDamageMod / 120) + (PercentAttackSpeedMod * 1.2) + (FlatCritChanceMod * 0.5)",
    "",
    "Aportes adicionales:",
    "- +0.10 si tag 'OnHit' presente",
    "- +0.05 bonus híbrido si AttackSpeed + OnHit + AbilityPower presentes",
    "",
    "Penalización de sinergia:",
    "- Si solo 1 de los ejes (AD, AS, Crit) existe → multiplicar score por 0.7",
    "- Si existen los 3 ejes → +0.05 bonus",
    "",
    "Caps:",
    "- Sin AttackSpeed → máximo 0.75",
    "- Sin PhysicalDamage → máximo 0.30 si tiene OnHit",
    "- Sin PhysicalDamage y sin OnHit → máximo 0.15",
    "",
    "Notas de calibración:",
    "- AttackSpeed es el multiplicador principal del DPS.",
    "- OnHit representa daño sostenido alternativo (ej híbridos tipo Nashor).",
    "- AD + Crit sin AS = daño fuerte pero no DPS máximo.",
    "",
    "==============================",
    "2. BURST AD (Ráfaga física)",
    "==============================",
    "Fórmula:",
    "(FlatPhysicalDamageMod / 110) + (Lethality / 30) + Pasivas_Burst",
    "",
    "Pasivas_Burst:",
    "- +0.25 proc daño plano / execute",
    "- +0.12 amplificador de crítico",
    "- +0.15 daño condicional fuerte desde descripción (máximo)",
    "",
    "Reglas de fuente vs amplificador:",
    "- AD alto es la fuente principal.",
    "- Amplificadores (crit dmg, executes, bonus damage) no pueden por sí solos llevar el score a 1.0.",
    "",
    "Caps:",
    "- Sin penetración/letalidad → máximo 0.90",
    "- Amplificador sin proc → máximo 0.85 (ej IE)",
    "",
    "Regla de 1.0:",
    "- 1.0 reservado para AD alto + penetración/letalidad + proc/execute",
    "",
    "==============================",
    "3. BURST AP (Ráfaga mágica)",
    "==============================",
    "Fórmula:",
    "(FlatMagicDamageMod / 160) + Pasivas_AP",
    "",
    "Pasivas_AP:",
    "- +0.25 amplificador porcentual AP (ej Rabadon)",
    "- +0.20 Spellblade / proc fuerte",
    "",
    "Reglas:",
    "- AP alto sin penetración ni proc fuerte → máximo 0.85",
    "- 1.0 requiere Fuente fuerte + amplificador + proc o penetración",
    "",
    "==============================",
    "4. TANKINESS (Supervivencia)",
    "==============================",
    "Fórmula:",
    "(FlatHPPoolMod / 1000) + (Armor / 160) + (MagicResist / 160)",
    "",
    "Reglas:",
    "- Sin resistencias → máximo 0.35",
    "- Vida + resistencias permite superar 0.60",
    "",
    "==============================",
    "5. ANTI-TANK",
    "==============================",
    "Asociación directa:",
    "- 0.85 si tiene penetración porcentual",
    "- 0.60 si daño % vida",
    "- Solo daño plano → máximo 0.10",
    "",
    "==============================",
    "6. SUSTAIN",
    "==============================",
    "- 0.8 si LifeSteal/Omnivamp significativo",
    "- Regen menor → <=0.3",
    "",
    "==============================",
    "7. ANTIHEAL",
    "==============================",
    "- 0.85 si aplica Grievous Wounds (reducción de curación)",
    "- 0.60 si la reducción es condicional o parcial",
    "- 0 si no tiene ningún efecto anti-curación",
    "",
    "==============================",
    "REGLA DE HÍBRIDOS",
    "==============================",
    "- Si un ítem contribuye a 3 o más señales → ninguna puede superar 0.70 salvo penetración o escalado porcentual fuerte",
    "- Los híbridos priorizan amplitud sobre picos",
    "",
    "==============================",
    "POLÍTICA DE TEXTO",
    "==============================",
    "- La descripción solo puede aportar máximo +0.15 a una señal",
    "- Los stats pesan más que el texto",
    "",
    "==============================",
    "INSTRUCCIÓN FINAL",
    "==============================",
    "Evita inflar valores altos.",
    "Prefiere consistencia relativa entre ítems del mismo arquetipo.",
    "Usa anchors implícitos del juego (IE, Rabadon, LDR, Void Staff) para calibrar la escala."
  ].join("\n");

  const outputFormat = [
    "",
    "==============================",
    "FORMATO DE SALIDA OBLIGATORIO",
    "==============================",
    'Responde UNICAMENTE un JSON con esta estructura exacta:',
    '{',
    '  "signals": {',
    '    "ITEM_ID": {',
    '      "tankiness": 0.0,',
    '      "physicalDps": 0.0,',
    '      "burstAd": 0.0,',
    '      "burstAp": 0.0,',
    '      "antiTank": 0.0,',
    '      "sustain": 0.0,',
    '      "antiHeal": 0.0',
    '    }',
    '  }',
    '}',
    '',
    'REGLAS DE FORMATO:',
    '- El wrapper "signals" es OBLIGATORIO.',
    '- Las keys de cada signal deben ser exactamente: tankiness, physicalDps, burstAd, burstAp, antiTank, sustain, antiHeal.',
    '- camelCase estricto, sin mayusculas.',
    '- ITEM_ID es el id numerico del item como string.',
    '- NO incluir campos extra como id, name, etc. Solo las 6 signals.',
    '- NO incluir texto, explicaciones ni markdown. Solo el JSON.',
  ].join("\n");

  const user = [
    "INPUT_JSON:",
    JSON.stringify({ items: itemsBatch }, null, 2),
    "",
    "Calcula los signals para TODOS los items del input. Se extremadamente critico con los valores altos.",
    outputFormat,
  ].join("\n");

  return { system, user };
}